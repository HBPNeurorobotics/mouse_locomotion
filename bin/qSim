#!/usr/bin/python2

##
# Mouse Locomotion Simulation
#
# Human Brain Project SP10
# 
# This project provides the user with a framework based on Blender allowing:
#  - Edition of a 3D model
#  - Edition of a physical controller model (torque-based or muscle-based)
#  - Edition of a brain controller model (oscillator-based or neural network-based)
#  - Simulation of the model
#  - Optimization of the parameters in distributed cloud simulations
# 
# File created by: Gabriel Urbain <gabriel.urbain@ugent.be>. February 2016
# Modified by: Dimitri Rodarie
##


# Add src folder to path
import logging.config
import os
from os.path import dirname, realpath
import sys

root = dirname(dirname(realpath(__file__))).replace("\\", "/")
src = root + "/src"
sys.path.append(src)

from plumbum import cli
from simulation import SimServer, Registry, Process


class SimCli(cli.Application):
    """This script provide a framework for quadruped locomotion driven by reservoir computing"""

    # Default CLI application options
    DEF_OPT = {"simulator": "BLENDER", "simulator_path": "/bin/Blender2.77/", "model": "dog_vert.blend",
               "root_dir": root,
               "config_name": "default_dog_vert_simulation_config",
               "sim_type": "RUN", "registry": False, "service": False, "local": False,
               "logfile": os.path.expanduser("~").replace("\\", "/") + "/.log/qSim.log",
               "fullscreen": False, "save": False, "load_file": False, "timeout": 120}

    # Simulation parameters
    max_cpu_percentage = cli.SwitchAttr(["-cpu", "--cpu_use"], str, default=None,
                                        help="Max CPU usage for the simulation servers")
    max_memory_percentage = cli.SwitchAttr(["-mem", "--mem_use"], str, default=None,
                                           help="Max memory usage for the simulation servers")
    simulator = cli.SwitchAttr(["-e", "--environment"], str, default=DEF_OPT["simulator"],
                               help="Simulator name : BLENDER")
    path = cli.SwitchAttr(["-p", "--binpath"], str, default=DEF_OPT["simulator_path"],
                          help="Path of Simulator binaries")
    model = cli.SwitchAttr(["-m", "--model"], str, default=DEF_OPT["model"],
                           help="Model to simulation")
    config = cli.SwitchAttr(["-c", "--config"], str, default=DEF_OPT["config_name"],
                            help="The config class to be used for simulation")
    sim_type = cli.SwitchAttr(["-t", "--type"], str, default=DEF_OPT["sim_type"],
                              help="Specify the type of simulation: RUN, META_GA or CM")
    sim_timeout = cli.SwitchAttr(["-d", "--timeout"], str, default=DEF_OPT["timeout"],
                                 help="Maximum duration for the simulation")

    # Server modes
    registry = cli.Flag(["-r"], default=DEF_OPT["registry"],
                        help="Start registry server; no simulation will be run")
    service = cli.Flag(["-s"], default=DEF_OPT["service"],
                       help="Start services server; no simulation will be run")
    local = cli.Flag(["-l"], default=DEF_OPT["local"],
                     help="Start a single local simulation. Used to bypass simulation distributed architecture")

    # Save and load config
    save = cli.Flag(["-S"], default=False,
                    help="Save the best individu at the end of sim (currently only for opti_brain)")
    load_file = cli.SwitchAttr(["-L"], str, default=False,
                               help="Start a single local simulation using result file")

    # Display modes
    root = cli.Flag(["--root"], default=DEF_OPT["root_dir"],
                    help="Force the root directory of the mouse locomotion software")
    verbose = cli.Flag(["-v", "--verbosemode"], default=False,
                       help="Set verbose mode")
    logfile = cli.SwitchAttr(["--logfile"], str, default=DEF_OPT["logfile"],
                             help="The log file to use")
    fullscreen = cli.Flag(["-f", "--fullscreen"], default=DEF_OPT["fullscreen"],
                          help="Enable fullscreen mode")

    def main(self):
        common_opt = {"root_dir": self.root,
                      "verbose": self.verbose,
                      "logfile": self.logfile}
        opt = common_opt.copy()
        opt["simulator"] = self.simulator
        opt["simulator_path"] = (self.root + self.path) if self.path == self.DEF_OPT["simulator_path"] else self.path
        opt["cpu_use"] = self.max_cpu_percentage if self.max_cpu_percentage is not None else 50
        opt["memory_use"] = self.max_memory_percentage if self.max_memory_percentage is not None else 90
        opt["model"] = self.root + "/mdl/" + self.model
        opt["config_name"] = self.root + "/configs/" + self.config + ".json"
        opt["sim_type"] = self.sim_type
        opt["fullscreen"] = self.fullscreen
        opt["local"] = self.local
        opt["load_file"] = self.load_file
        opt["save"] = self.save
        opt["timeout"] = self.sim_timeout

        # Configure logging
        log_file = opt["logfile"]
        if not os.path.exists(os.path.dirname(log_file)):
            os.makedirs(os.path.dirname(log_file))
        if not os.path.exists(log_file):
            f = open(log_file, 'w')
            f.close()
        if self.verbose:
            logging.config.fileConfig(root + "/etc/logging.conf",
                                      defaults={'logfilename': log_file,
                                                'simLevel': "DEBUG"})
        else:
            logging.config.fileConfig(root + "/etc/logging.conf",
                                      defaults={'logfilename': log_file,
                                                'simLevel': "INFO"})

        # Start a local simulation
        if self.local:
            s = Process(opt)
        elif self.registry:
            s = Registry(common_opt)
        elif self.service:
            s = SimServer(common_opt)
        # Else, start chosen simulation
        else:
            s = Process(opt)
        s.start()


if __name__ == "__main__":
    SimCli.run()
